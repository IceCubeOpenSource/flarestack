%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Flarestack Documentation}
\date{May 28, 2019}
\release{2.0-beta.1}
\author{Robert Stein}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Base PDFs}
\label{\detokenize{index:base-pdfs}}

\section{Time PDFs}
\label{\detokenize{index:module-flarestack.core.time_pdf}}\label{\detokenize{index:time-pdfs}}\index{flarestack.core.time\_pdf (module)@\spxentry{flarestack.core.time\_pdf}\spxextra{module}}\index{Box (class in flarestack.core.time\_pdf)@\spxentry{Box}\spxextra{class in flarestack.core.time\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.time\_pdf.}}\sphinxbfcode{\sphinxupquote{Box}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
The simplest time-dependent case for a Time PDF. Used for a source that
is uniformly emitting for a fixed period of time. Requires arguments of
Pre-Window and Post\_window, and gives a box from Pre-Window days before
the reference time to Post-Window days after the reference time.
\index{\_\_init\_\_() (flarestack.core.time\_pdf.Box method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{effective\_injection\_time() (flarestack.core.time\_pdf.Box method)@\spxentry{effective\_injection\_time()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.effective_injection_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{effective\_injection\_time}}}{\emph{source}}{}
Calculates the effective injection time for the given PDF.
The livetime is measured in days, but here is converted to seconds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Effective Livetime in seconds

\end{description}\end{quote}

\end{fulllineitems}

\index{flare\_time\_mask() (flarestack.core.time\_pdf.Box method)@\spxentry{flare\_time\_mask()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.flare_time_mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flare\_time\_mask}}}{\emph{source}}{}
In this case, the interesting period for Flare Searches is the
period of overlap of the flare and the box. Thus, for a given season,
return the source and data
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Start time (MJD) and End Time (MJD) for flare search period

\end{description}\end{quote}

\end{fulllineitems}

\index{raw\_injection\_time() (flarestack.core.time\_pdf.Box method)@\spxentry{raw\_injection\_time()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.raw_injection_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{raw\_injection\_time}}}{\emph{source}}{}
Calculates the ‘raw injection time’ which is the injection time
assuming a detector with 100\% uptime. Useful for calculating source
emission times for source-frame energy estimation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time in seconds for 100\% uptime

\end{description}\end{quote}

\end{fulllineitems}

\index{sig\_t0() (flarestack.core.time\_pdf.Box method)@\spxentry{sig\_t0()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.sig_t0}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t0}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD minus the length of the pre-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window Start

\end{description}\end{quote}

\end{fulllineitems}

\index{sig\_t1() (flarestack.core.time\_pdf.Box method)@\spxentry{sig\_t1()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.sig_t1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t1}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD plus the length of the post-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window End

\end{description}\end{quote}

\end{fulllineitems}

\index{signal\_f() (flarestack.core.time\_pdf.Box method)@\spxentry{signal\_f()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.signal_f}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{signal\_f}}}{\emph{t}, \emph{source}}{}
In this case, the signal PDF is a uniform PDF for a fixed duration of
time. It is normalised with the length of the box in LIVETIME rather
than days, to give an integral of 1.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} Time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\end{itemize}

\item[{Returns}] \leavevmode
Value of normalised box function at t

\end{description}\end{quote}

\end{fulllineitems}

\index{signal\_integral() (flarestack.core.time\_pdf.Box method)@\spxentry{signal\_integral()}\spxextra{flarestack.core.time\_pdf.Box method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Box.signal_integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{signal\_integral}}}{\emph{t}, \emph{source}}{}
In this case, the signal PDF is a uniform PDF for a fixed duration of
time. Thus, the integral is simply a linear function increasing
between t0 (box start) and t1 (box end). After t1, the integral is
equal to 1, while it is equal to 0 for t \textless{} t0.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} Time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\end{itemize}

\item[{Returns}] \leavevmode
Value of normalised box function at t

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FixedEndBox (class in flarestack.core.time\_pdf)@\spxentry{FixedEndBox}\spxextra{class in flarestack.core.time\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedEndBox}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.time\_pdf.}}\sphinxbfcode{\sphinxupquote{FixedEndBox}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
The simplest time-dependent case for a Time PDF. Used for a source that
is uniformly emitting for a fixed period of time. In this case, the start
and end time for the box is unique for each source. The sources must have
a field “Start Time (MJD)” and another “End Time (MJD)”, specifying the
period of the Time PDF.
\index{\_\_init\_\_() (flarestack.core.time\_pdf.FixedEndBox method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.time\_pdf.FixedEndBox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedEndBox.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{sig\_t0() (flarestack.core.time\_pdf.FixedEndBox method)@\spxentry{sig\_t0()}\spxextra{flarestack.core.time\_pdf.FixedEndBox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedEndBox.sig_t0}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t0}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD minus the length of the pre-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window Start

\end{description}\end{quote}

\end{fulllineitems}

\index{sig\_t1() (flarestack.core.time\_pdf.FixedEndBox method)@\spxentry{sig\_t1()}\spxextra{flarestack.core.time\_pdf.FixedEndBox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedEndBox.sig_t1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t1}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD plus the length of the post-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window End

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FixedRefBox (class in flarestack.core.time\_pdf)@\spxentry{FixedRefBox}\spxextra{class in flarestack.core.time\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedRefBox}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.time\_pdf.}}\sphinxbfcode{\sphinxupquote{FixedRefBox}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
The simplest time-dependent case for a Time PDF. Used for a source that
is uniformly emitting for a fixed period of time. In this case, the start
and end time for the box is unique for each source. The sources must have
a field “Start Time (MJD)” and another “End Time (MJD)”, specifying the
period of the Time PDF.
\index{\_\_init\_\_() (flarestack.core.time\_pdf.FixedRefBox method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.time\_pdf.FixedRefBox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedRefBox.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{sig\_t0() (flarestack.core.time\_pdf.FixedRefBox method)@\spxentry{sig\_t0()}\spxextra{flarestack.core.time\_pdf.FixedRefBox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedRefBox.sig_t0}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t0}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD minus the length of the pre-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window Start

\end{description}\end{quote}

\end{fulllineitems}

\index{sig\_t1() (flarestack.core.time\_pdf.FixedRefBox method)@\spxentry{sig\_t1()}\spxextra{flarestack.core.time\_pdf.FixedRefBox method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.FixedRefBox.sig_t1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t1}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD plus the length of the post-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window End

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Steady (class in flarestack.core.time\_pdf)@\spxentry{Steady}\spxextra{class in flarestack.core.time\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.time\_pdf.}}\sphinxbfcode{\sphinxupquote{Steady}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
The time-independent case for a Time PDF. Requires no additional
arguments in the dictionary for \_\_init\_\_. Used for a steady source that
is continuously emitting.
\index{effective\_injection\_time() (flarestack.core.time\_pdf.Steady method)@\spxentry{effective\_injection\_time()}\spxextra{flarestack.core.time\_pdf.Steady method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady.effective_injection_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{effective\_injection\_time}}}{\emph{source}}{}
Calculates the effective injection time for the given PDF.
The livetime is measured in days, but here is converted to seconds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Effective Livetime in seconds

\end{description}\end{quote}

\end{fulllineitems}

\index{flare\_time\_mask() (flarestack.core.time\_pdf.Steady method)@\spxentry{flare\_time\_mask()}\spxextra{flarestack.core.time\_pdf.Steady method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady.flare_time_mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flare\_time\_mask}}}{\emph{source}}{}
In this case, the interesting period for Flare Searches is the
entire season. Thus returns the start and end times for the season.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Start time (MJD) and End Time (MJD) for flare search period

\end{description}\end{quote}

\end{fulllineitems}

\index{raw\_injection\_time() (flarestack.core.time\_pdf.Steady method)@\spxentry{raw\_injection\_time()}\spxextra{flarestack.core.time\_pdf.Steady method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady.raw_injection_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{raw\_injection\_time}}}{\emph{source}}{}
Calculates the ‘raw injection time’ which is the injection time
assuming a detector with 100\% uptime. Useful for calculating source
emission times for source-frame energy estimation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time in seconds for 100\% uptime

\end{description}\end{quote}

\end{fulllineitems}

\index{sig\_t0() (flarestack.core.time\_pdf.Steady method)@\spxentry{sig\_t0()}\spxextra{flarestack.core.time\_pdf.Steady method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady.sig_t0}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t0}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD minus the length of the pre-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window Start

\end{description}\end{quote}

\end{fulllineitems}

\index{sig\_t1() (flarestack.core.time\_pdf.Steady method)@\spxentry{sig\_t1()}\spxextra{flarestack.core.time\_pdf.Steady method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady.sig_t1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sig\_t1}}}{\emph{source}}{}
Calculates the starting time for the window, equal to the
source reference time in MJD plus the length of the post-reference-time
window (in days).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Time of Window End

\end{description}\end{quote}

\end{fulllineitems}

\index{signal\_f() (flarestack.core.time\_pdf.Steady method)@\spxentry{signal\_f()}\spxextra{flarestack.core.time\_pdf.Steady method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady.signal_f}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{signal\_f}}}{\emph{t}, \emph{source}}{}
In the case of a steady source, the signal PDF is a uniform PDF in
time. It is thus simply equal to the season\_f, normalised with the
length of the season to give an integral of 1. It is thus equal to
the background PDF.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} Time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\end{itemize}

\item[{Returns}] \leavevmode
Value of normalised box function at t

\end{description}\end{quote}

\end{fulllineitems}

\index{signal\_integral() (flarestack.core.time\_pdf.Steady method)@\spxentry{signal\_integral()}\spxextra{flarestack.core.time\_pdf.Steady method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.Steady.signal_integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{signal\_integral}}}{\emph{t}, \emph{source}}{}
In the case of a steady source, the signal PDF is a uniform PDF in
time. Thus, the integral is simply a linear function increasing
between t0 (box start) and t1 (box end). After t1, the integral is
equal to 1, while it is equal to 0 for t \textless{} t0.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} Time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\end{itemize}

\item[{Returns}] \leavevmode
Value of normalised box function at t

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TimePDF (class in flarestack.core.time\_pdf)@\spxentry{TimePDF}\spxextra{class in flarestack.core.time\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.time\_pdf.}}\sphinxbfcode{\sphinxupquote{TimePDF}}}{\emph{t\_pdf\_dict}, \emph{season}}{}~\index{\_\_init\_\_() (flarestack.core.time\_pdf.TimePDF method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.time\_pdf.TimePDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{background\_f() (flarestack.core.time\_pdf.TimePDF method)@\spxentry{background\_f()}\spxextra{flarestack.core.time\_pdf.TimePDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.background_f}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{background\_f}}}{\emph{t}, \emph{source}}{}
In all cases, we assume that the background is uniform in time.
Thus, the background PDF is just a normalised version of the season\_f
box function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} Time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\end{itemize}

\item[{Returns}] \leavevmode
Value of normalised box function at t

\end{description}\end{quote}

\end{fulllineitems}

\index{create() (flarestack.core.time\_pdf.TimePDF class method)@\spxentry{create()}\spxextra{flarestack.core.time\_pdf.TimePDF class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{t\_pdf\_dict}, \emph{season}}{}
\end{fulllineitems}

\index{inverse\_interpolate() (flarestack.core.time\_pdf.TimePDF method)@\spxentry{inverse\_interpolate()}\spxextra{flarestack.core.time\_pdf.TimePDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.inverse_interpolate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inverse\_interpolate}}}{\emph{source}}{}
Calculates the values for the integral of the signal PDF within
the season. Then rescales these values, such that the start of the
season yields 0, and then end of the season yields 1. Creates a
function to interpolate between these values. Then, for a number
between 0 and 1, the interpolated function will return the MJD time
at which that fraction of the cumulative distribution was reached.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item[{Returns}] \leavevmode
Interpolated function

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_integral() (flarestack.core.time\_pdf.TimePDF method)@\spxentry{product\_integral()}\spxextra{flarestack.core.time\_pdf.TimePDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.product_integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{product\_integral}}}{\emph{t}, \emph{source}}{}
Calculates the product of the given signal PDF with the season box
function. Thus gives 0 everywhere outside the season, and otherwise
the value of the normalised integral. The season function is offset
by 1e-9, to ensure that f(t1) is equal to 1. (i.e the function is
equal to 1 at the end of the box).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} Time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\end{itemize}

\item[{Returns}] \leavevmode
Product of signal integral and season

\end{description}\end{quote}

\end{fulllineitems}

\index{register\_subclass() (flarestack.core.time\_pdf.TimePDF class method)@\spxentry{register\_subclass()}\spxextra{flarestack.core.time\_pdf.TimePDF class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.register_subclass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{register\_subclass}}}{\emph{time\_pdf\_name}}{}
\end{fulllineitems}

\index{simulate\_times() (flarestack.core.time\_pdf.TimePDF method)@\spxentry{simulate\_times()}\spxextra{flarestack.core.time\_pdf.TimePDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.simulate_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate\_times}}}{\emph{source}, \emph{n\_s}}{}
Randomly draws times for n\_s events for a given source,
all lying within the current season. The values are based on an
interpolation of the integrated time PDF.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source being considered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_s}} \textendash{} Number of event times to be simulated

\end{itemize}

\item[{Returns}] \leavevmode
Array of times in MJD for a given source

\end{description}\end{quote}

\end{fulllineitems}

\index{subclasses (flarestack.core.time\_pdf.TimePDF attribute)@\spxentry{subclasses}\spxextra{flarestack.core.time\_pdf.TimePDF attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.TimePDF.subclasses}}\pysigline{\sphinxbfcode{\sphinxupquote{subclasses}}\sphinxbfcode{\sphinxupquote{ = \{'Box': \textless{}class 'flarestack.core.time\_pdf.Box'\textgreater{}, 'FixedEndBox': \textless{}class 'flarestack.core.time\_pdf.FixedEndBox'\textgreater{}, 'FixedRefBox': \textless{}class 'flarestack.core.time\_pdf.FixedRefBox'\textgreater{}, 'Steady': \textless{}class 'flarestack.core.time\_pdf.Steady'\textgreater{}\}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{box\_func() (in module flarestack.core.time\_pdf)@\spxentry{box\_func()}\spxextra{in module flarestack.core.time\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.box_func}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.core.time\_pdf.}}\sphinxbfcode{\sphinxupquote{box\_func}}}{\emph{t}, \emph{t0}, \emph{t1}}{}
Box function that is equal to 1 between t0 and t1, and 0 otherwise.
Equal to 0.5 at to and t1.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} Time to be evaluated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t0}} \textendash{} Start time of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t1}} \textendash{} End time of box

\end{itemize}

\item[{Returns}] \leavevmode
Value of Box function at t

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_t\_pdf\_dict() (in module flarestack.core.time\_pdf)@\spxentry{read\_t\_pdf\_dict()}\spxextra{in module flarestack.core.time\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.time_pdf.read_t_pdf_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.core.time\_pdf.}}\sphinxbfcode{\sphinxupquote{read\_t\_pdf\_dict}}}{\emph{t\_pdf\_dict}}{}
Ensures backwards compatibility for t\_pdf\_dict objects

\end{fulllineitems}



\section{Energy PDFs}
\label{\detokenize{index:module-flarestack.core.energy_pdf}}\label{\detokenize{index:energy-pdfs}}\index{flarestack.core.energy\_pdf (module)@\spxentry{flarestack.core.energy\_pdf}\spxextra{module}}
This script contains the EnergyPDF classes, that are used for weighting
events based on a given energy PDF.
\index{EnergyPDF (class in flarestack.core.energy\_pdf)@\spxentry{EnergyPDF}\spxextra{class in flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{EnergyPDF}}}{\emph{e\_pdf\_dict}}{}~\index{\_\_init\_\_() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{e\_pdf\_dict}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{create() (flarestack.core.energy\_pdf.EnergyPDF class method)@\spxentry{create()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{e\_pdf\_dict}}{}
\end{fulllineitems}

\index{f() (flarestack.core.energy\_pdf.EnergyPDF static method)@\spxentry{f()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.f}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{f}}}{\emph{energy}}{}
\end{fulllineitems}

\index{fluence\_integral() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{fluence\_integral()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.fluence_integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fluence\_integral}}}{}{}
Performs an integral for fluence over a given energy range. This is
gives the total energy per unit area per second that is radiated.

\end{fulllineitems}

\index{flux\_integral() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{flux\_integral()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.flux_integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flux\_integral}}}{}{}
Integrates over energy PDF to give integrated flux (dN/dT)

\end{fulllineitems}

\index{integrate\_over\_E() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{integrate\_over\_E()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.integrate_over_E}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_over\_E}}}{\emph{f}, \emph{lower=None}, \emph{upper=None}}{}
Uses Newton’s method to integrate function f over the energy
range. By default, uses 100GeV to 10PeV, unless otherwise specified.
Uses 1000 logarithmically-spaced bins to calculate integral.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} Function to be integrated

\item[{Returns}] \leavevmode
Integral of function

\end{description}\end{quote}

\end{fulllineitems}

\index{register\_subclass() (flarestack.core.energy\_pdf.EnergyPDF class method)@\spxentry{register\_subclass()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.register_subclass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{register\_subclass}}}{\emph{energy\_pdf\_name}}{}
Adds a new subclass of EnergyPDF, with class name equal to
“energy\_pdf\_name”.

\end{fulllineitems}

\index{return\_energy\_parameters() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{return\_energy\_parameters()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.return_energy_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{return\_energy\_parameters}}}{}{}
\end{fulllineitems}

\index{subclasses (flarestack.core.energy\_pdf.EnergyPDF attribute)@\spxentry{subclasses}\spxextra{flarestack.core.energy\_pdf.EnergyPDF attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.EnergyPDF.subclasses}}\pysigline{\sphinxbfcode{\sphinxupquote{subclasses}}\sphinxbfcode{\sphinxupquote{ = \{'PowerLaw': \textless{}class 'flarestack.core.energy\_pdf.PowerLaw'\textgreater{}, 'Spline': \textless{}class 'flarestack.core.energy\_pdf.Spline'\textgreater{}\}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{PowerLaw (class in flarestack.core.energy\_pdf)@\spxentry{PowerLaw}\spxextra{class in flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{PowerLaw}}}{\emph{e\_pdf\_dict=None}}{}
A Power Law energy PDF. Takes an argument of gamma in the dictionary
for the init function, where gamma is the spectral index of the Power Law.
\index{\_\_init\_\_() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{e\_pdf\_dict=None}}{}
Creates a PowerLaw object, which is an energy PDF based on a power
law. The power law is generated from e\_pdf\_dict, which can specify a
spectral index (Gamma), as well as an optional minimum energy (E Min)
and a maximum energy (E Max)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{e\_pdf\_dict}} \textendash{} Dictionary containing parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{f() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{f()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw.f}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{f}}}{\emph{energy}}{}
\end{fulllineitems}

\index{fluence\_integral() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{fluence\_integral()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw.fluence_integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fluence\_integral}}}{}{}
Performs an integral for fluence over a given energy range. This is
gives the total energy per unit area per second that is radiated.

\end{fulllineitems}

\index{flux\_integral() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{flux\_integral()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw.flux_integral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flux\_integral}}}{}{}
Integrates over energy PDF to give integrated flux (dN/dT)

\end{fulllineitems}

\index{return\_energy\_parameters() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{return\_energy\_parameters()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw.return_energy_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{return\_energy\_parameters}}}{}{}
\end{fulllineitems}

\index{return\_injected\_parameters() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{return\_injected\_parameters()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw.return_injected_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{return\_injected\_parameters}}}{}{}
\end{fulllineitems}

\index{weight\_mc() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{weight\_mc()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.PowerLaw.weight_mc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{weight\_mc}}}{\emph{mc}, \emph{gamma=None}}{}
Returns an array containing the weights for each MC event,
given that the spectral index gamma has been chosen. Weights each
event as (E/GeV)\textasciicircum{}-gamma, and multiplies this by the pre-existing MC
oneweight value, to give the overall oneweight.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mc}} \textendash{} Monte Carlo

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} Spectral Index (default is value in e\_pdf\_dict)

\end{itemize}

\item[{Returns}] \leavevmode
Weights Array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Spline (class in flarestack.core.energy\_pdf)@\spxentry{Spline}\spxextra{class in flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.Spline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{Spline}}}{\emph{e\_pdf\_dict=\{\}}}{}
A Power Law energy PDF. Takes an argument of gamma in the dictionary
for the init function, where gamma is the spectral index of the Power Law.
\index{\_\_init\_\_() (flarestack.core.energy\_pdf.Spline method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.energy\_pdf.Spline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.Spline.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{e\_pdf\_dict=\{\}}}{}
Creates a PowerLaw object, which is an energy PDF based on a power
law. The power law is generated from e\_pdf\_dict, which can specify a
spectral index (Gamma), as well as an optional minimum energy (E Min)
and a maximum energy (E Max)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{e\_pdf\_dict}} \textendash{} Dictionary containing parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{weight\_mc() (flarestack.core.energy\_pdf.Spline method)@\spxentry{weight\_mc()}\spxextra{flarestack.core.energy\_pdf.Spline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.Spline.weight_mc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{weight\_mc}}}{\emph{mc}}{}
Returns an array containing the weights for each MC event,
given that the spectral index gamma has been chosen. Weights each
event using the energy spline, and multiplies this by the
pre-existing MC oneweight value, to give the overall oneweight.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mc}} \textendash{} Monte Carlo

\item[{Returns}] \leavevmode
Weights Array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{read\_e\_pdf\_dict() (in module flarestack.core.energy\_pdf)@\spxentry{read\_e\_pdf\_dict()}\spxextra{in module flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.energy_pdf.read_e_pdf_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{read\_e\_pdf\_dict}}}{\emph{e\_pdf\_dict}}{}
Ensures backwards compatibility of e\_pdf\_dict objects.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{e\_pdf\_dict}} \textendash{} Energy PDF dictionary

\item[{Returns}] \leavevmode
Updated Energy PDF dictionary compatible with new format

\end{description}\end{quote}

\end{fulllineitems}



\section{Spatial PDFs}
\label{\detokenize{index:module-flarestack.core.energy_pdf}}\label{\detokenize{index:spatial-pdfs}}\index{flarestack.core.energy\_pdf (module)@\spxentry{flarestack.core.energy\_pdf}\spxextra{module}}
This script contains the EnergyPDF classes, that are used for weighting
events based on a given energy PDF.
\index{EnergyPDF (class in flarestack.core.energy\_pdf)@\spxentry{EnergyPDF}\spxextra{class in flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{EnergyPDF}}}{\emph{e\_pdf\_dict}}{}~\index{\_\_init\_\_() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{e\_pdf\_dict}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{create() (flarestack.core.energy\_pdf.EnergyPDF class method)@\spxentry{create()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF class method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{e\_pdf\_dict}}{}
\end{fulllineitems}

\index{f() (flarestack.core.energy\_pdf.EnergyPDF static method)@\spxentry{f()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF static method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{f}}}{\emph{energy}}{}
\end{fulllineitems}

\index{fluence\_integral() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{fluence\_integral()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fluence\_integral}}}{}{}
Performs an integral for fluence over a given energy range. This is
gives the total energy per unit area per second that is radiated.

\end{fulllineitems}

\index{flux\_integral() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{flux\_integral()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flux\_integral}}}{}{}
Integrates over energy PDF to give integrated flux (dN/dT)

\end{fulllineitems}

\index{integrate\_over\_E() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{integrate\_over\_E()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_over\_E}}}{\emph{f}, \emph{lower=None}, \emph{upper=None}}{}
Uses Newton’s method to integrate function f over the energy
range. By default, uses 100GeV to 10PeV, unless otherwise specified.
Uses 1000 logarithmically-spaced bins to calculate integral.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} Function to be integrated

\item[{Returns}] \leavevmode
Integral of function

\end{description}\end{quote}

\end{fulllineitems}

\index{register\_subclass() (flarestack.core.energy\_pdf.EnergyPDF class method)@\spxentry{register\_subclass()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF class method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{register\_subclass}}}{\emph{energy\_pdf\_name}}{}
Adds a new subclass of EnergyPDF, with class name equal to
“energy\_pdf\_name”.

\end{fulllineitems}

\index{return\_energy\_parameters() (flarestack.core.energy\_pdf.EnergyPDF method)@\spxentry{return\_energy\_parameters()}\spxextra{flarestack.core.energy\_pdf.EnergyPDF method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{return\_energy\_parameters}}}{}{}
\end{fulllineitems}

\index{subclasses (flarestack.core.energy\_pdf.EnergyPDF attribute)@\spxentry{subclasses}\spxextra{flarestack.core.energy\_pdf.EnergyPDF attribute}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{subclasses}}\sphinxbfcode{\sphinxupquote{ = \{'PowerLaw': \textless{}class 'flarestack.core.energy\_pdf.PowerLaw'\textgreater{}, 'Spline': \textless{}class 'flarestack.core.energy\_pdf.Spline'\textgreater{}\}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{PowerLaw (class in flarestack.core.energy\_pdf)@\spxentry{PowerLaw}\spxextra{class in flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{PowerLaw}}}{\emph{e\_pdf\_dict=None}}{}
A Power Law energy PDF. Takes an argument of gamma in the dictionary
for the init function, where gamma is the spectral index of the Power Law.
\index{\_\_init\_\_() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{e\_pdf\_dict=None}}{}
Creates a PowerLaw object, which is an energy PDF based on a power
law. The power law is generated from e\_pdf\_dict, which can specify a
spectral index (Gamma), as well as an optional minimum energy (E Min)
and a maximum energy (E Max)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{e\_pdf\_dict}} \textendash{} Dictionary containing parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{f() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{f()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{f}}}{\emph{energy}}{}
\end{fulllineitems}

\index{fluence\_integral() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{fluence\_integral()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fluence\_integral}}}{}{}
Performs an integral for fluence over a given energy range. This is
gives the total energy per unit area per second that is radiated.

\end{fulllineitems}

\index{flux\_integral() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{flux\_integral()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flux\_integral}}}{}{}
Integrates over energy PDF to give integrated flux (dN/dT)

\end{fulllineitems}

\index{return\_energy\_parameters() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{return\_energy\_parameters()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{return\_energy\_parameters}}}{}{}
\end{fulllineitems}

\index{return\_injected\_parameters() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{return\_injected\_parameters()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{return\_injected\_parameters}}}{}{}
\end{fulllineitems}

\index{weight\_mc() (flarestack.core.energy\_pdf.PowerLaw method)@\spxentry{weight\_mc()}\spxextra{flarestack.core.energy\_pdf.PowerLaw method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{weight\_mc}}}{\emph{mc}, \emph{gamma=None}}{}
Returns an array containing the weights for each MC event,
given that the spectral index gamma has been chosen. Weights each
event as (E/GeV)\textasciicircum{}-gamma, and multiplies this by the pre-existing MC
oneweight value, to give the overall oneweight.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mc}} \textendash{} Monte Carlo

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} Spectral Index (default is value in e\_pdf\_dict)

\end{itemize}

\item[{Returns}] \leavevmode
Weights Array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Spline (class in flarestack.core.energy\_pdf)@\spxentry{Spline}\spxextra{class in flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{Spline}}}{\emph{e\_pdf\_dict=\{\}}}{}
A Power Law energy PDF. Takes an argument of gamma in the dictionary
for the init function, where gamma is the spectral index of the Power Law.
\index{\_\_init\_\_() (flarestack.core.energy\_pdf.Spline method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.energy\_pdf.Spline method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{e\_pdf\_dict=\{\}}}{}
Creates a PowerLaw object, which is an energy PDF based on a power
law. The power law is generated from e\_pdf\_dict, which can specify a
spectral index (Gamma), as well as an optional minimum energy (E Min)
and a maximum energy (E Max)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{e\_pdf\_dict}} \textendash{} Dictionary containing parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{weight\_mc() (flarestack.core.energy\_pdf.Spline method)@\spxentry{weight\_mc()}\spxextra{flarestack.core.energy\_pdf.Spline method}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{weight\_mc}}}{\emph{mc}}{}
Returns an array containing the weights for each MC event,
given that the spectral index gamma has been chosen. Weights each
event using the energy spline, and multiplies this by the
pre-existing MC oneweight value, to give the overall oneweight.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mc}} \textendash{} Monte Carlo

\item[{Returns}] \leavevmode
Weights Array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{read\_e\_pdf\_dict() (in module flarestack.core.energy\_pdf)@\spxentry{read\_e\_pdf\_dict()}\spxextra{in module flarestack.core.energy\_pdf}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.core.energy\_pdf.}}\sphinxbfcode{\sphinxupquote{read\_e\_pdf\_dict}}}{\emph{e\_pdf\_dict}}{}
Ensures backwards compatibility of e\_pdf\_dict objects.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{e\_pdf\_dict}} \textendash{} Energy PDF dictionary

\item[{Returns}] \leavevmode
Updated Energy PDF dictionary compatible with new format

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Composite PDF Objects}
\label{\detokenize{index:composite-pdf-objects}}

\section{Injector}
\label{\detokenize{index:module-flarestack.core.injector}}\label{\detokenize{index:injector}}\index{flarestack.core.injector (module)@\spxentry{flarestack.core.injector}\spxextra{module}}\index{BaseInjector (class in flarestack.core.injector)@\spxentry{BaseInjector}\spxextra{class in flarestack.core.injector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.injector.}}\sphinxbfcode{\sphinxupquote{BaseInjector}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Base Injector Class
\index{\_\_init\_\_() (flarestack.core.injector.BaseInjector method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{calculate\_n\_exp() (flarestack.core.injector.BaseInjector method)@\spxentry{calculate\_n\_exp()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.calculate_n_exp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_n\_exp}}}{}{}
\end{fulllineitems}

\index{calculate\_n\_exp\_single() (flarestack.core.injector.BaseInjector method)@\spxentry{calculate\_n\_exp\_single()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.calculate_n_exp_single}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_n\_exp\_single}}}{\emph{source}}{}
\end{fulllineitems}

\index{create() (flarestack.core.injector.BaseInjector class method)@\spxentry{create()}\spxextra{flarestack.core.injector.BaseInjector class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{create\_dataset() (flarestack.core.injector.BaseInjector method)@\spxentry{create\_dataset()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.create_dataset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_dataset}}}{\emph{scale}, \emph{pull\_corrector}}{}
Create a dataset based on scrambled data for background, and Monte
Carlo simulation for signal. Returns the composite dataset. The source
flux can be scaled by the scale parameter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} Ratio of Injected Flux to source flux

\item[{Returns}] \leavevmode
Simulated dataset

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dec\_and\_omega() (flarestack.core.injector.BaseInjector static method)@\spxentry{get\_dec\_and\_omega()}\spxextra{flarestack.core.injector.BaseInjector static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.get_dec_and_omega}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_dec\_and\_omega}}}{\emph{source}}{}
\end{fulllineitems}

\index{get\_expectation() (flarestack.core.injector.BaseInjector method)@\spxentry{get\_expectation()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.get_expectation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_expectation}}}{\emph{source}, \emph{scale}}{}
\end{fulllineitems}

\index{get\_n\_exp\_single() (flarestack.core.injector.BaseInjector method)@\spxentry{get\_n\_exp\_single()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.get_n_exp_single}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_n\_exp\_single}}}{\emph{source}}{}
\end{fulllineitems}

\index{inject\_signal() (flarestack.core.injector.BaseInjector method)@\spxentry{inject\_signal()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.inject_signal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inject\_signal}}}{\emph{scale}}{}
\end{fulllineitems}

\index{register\_subclass() (flarestack.core.injector.BaseInjector class method)@\spxentry{register\_subclass()}\spxextra{flarestack.core.injector.BaseInjector class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.register_subclass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{register\_subclass}}}{\emph{inj\_name}}{}
Adds a new subclass of EnergyPDF, with class name equal to
“energy\_pdf\_name”.

\end{fulllineitems}

\index{subclasses (flarestack.core.injector.BaseInjector attribute)@\spxentry{subclasses}\spxextra{flarestack.core.injector.BaseInjector attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.subclasses}}\pysigline{\sphinxbfcode{\sphinxupquote{subclasses}}\sphinxbfcode{\sphinxupquote{ = \{\}}}}
\end{fulllineitems}

\index{update\_sources() (flarestack.core.injector.BaseInjector method)@\spxentry{update\_sources()}\spxextra{flarestack.core.injector.BaseInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.BaseInjector.update_sources}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_sources}}}{\emph{sources}}{}
Reuses an injector with new sources
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{sources}} \textendash{} Sources to be added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{EffectiveAreaInjector (class in flarestack.core.injector)@\spxentry{EffectiveAreaInjector}\spxextra{class in flarestack.core.injector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.EffectiveAreaInjector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.injector.}}\sphinxbfcode{\sphinxupquote{EffectiveAreaInjector}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Class for injecting signal events by relying on effective areas rather
than pre-existing Monte Carlo simulation. This Injector should be used
for analysing public data, as no MC is provided.
\index{\_\_init\_\_() (flarestack.core.injector.EffectiveAreaInjector method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.injector.EffectiveAreaInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.EffectiveAreaInjector.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{calculate\_energy\_proxy() (flarestack.core.injector.EffectiveAreaInjector method)@\spxentry{calculate\_energy\_proxy()}\spxextra{flarestack.core.injector.EffectiveAreaInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.EffectiveAreaInjector.calculate_energy_proxy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_energy\_proxy}}}{\emph{source}}{}
\end{fulllineitems}

\index{calculate\_n\_exp\_single() (flarestack.core.injector.EffectiveAreaInjector method)@\spxentry{calculate\_n\_exp\_single()}\spxextra{flarestack.core.injector.EffectiveAreaInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.EffectiveAreaInjector.calculate_n_exp_single}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_n\_exp\_single}}}{\emph{source}}{}
\end{fulllineitems}

\index{calculate\_single\_source() (flarestack.core.injector.EffectiveAreaInjector method)@\spxentry{calculate\_single\_source()}\spxextra{flarestack.core.injector.EffectiveAreaInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.EffectiveAreaInjector.calculate_single_source}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_single\_source}}}{\emph{source}, \emph{scale}}{}
\end{fulllineitems}

\index{inject\_signal() (flarestack.core.injector.EffectiveAreaInjector method)@\spxentry{inject\_signal()}\spxextra{flarestack.core.injector.EffectiveAreaInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.EffectiveAreaInjector.inject_signal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inject\_signal}}}{\emph{scale}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{LowMemoryInjector (class in flarestack.core.injector)@\spxentry{LowMemoryInjector}\spxextra{class in flarestack.core.injector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.LowMemoryInjector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.injector.}}\sphinxbfcode{\sphinxupquote{LowMemoryInjector}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
For large numbers of sources O(\textasciitilde{}100), saving MC masks becomes
increasingly burdensome. As a solution, the LowMemoryInjector should be
used instead. It will be somewhat slower, but will have much more
reasonable memory consumption.
\index{\_\_init\_\_() (flarestack.core.injector.LowMemoryInjector method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.injector.LowMemoryInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.LowMemoryInjector.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{calculate\_n\_exp() (flarestack.core.injector.LowMemoryInjector method)@\spxentry{calculate\_n\_exp()}\spxextra{flarestack.core.injector.LowMemoryInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.LowMemoryInjector.calculate_n_exp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_n\_exp}}}{}{}
\end{fulllineitems}

\index{get\_band\_mask() (flarestack.core.injector.LowMemoryInjector method)@\spxentry{get\_band\_mask()}\spxextra{flarestack.core.injector.LowMemoryInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.LowMemoryInjector.get_band_mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_band\_mask}}}{\emph{source}, \emph{min\_dec}, \emph{max\_dec}}{}
\end{fulllineitems}

\index{load\_band\_mask() (flarestack.core.injector.LowMemoryInjector method)@\spxentry{load\_band\_mask()}\spxextra{flarestack.core.injector.LowMemoryInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.LowMemoryInjector.load_band_mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_band\_mask}}}{\emph{index}}{}
\end{fulllineitems}

\index{make\_injection\_band\_mask() (flarestack.core.injector.LowMemoryInjector method)@\spxentry{make\_injection\_band\_mask()}\spxextra{flarestack.core.injector.LowMemoryInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.LowMemoryInjector.make_injection_band_mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_injection\_band\_mask}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{MCInjector (class in flarestack.core.injector)@\spxentry{MCInjector}\spxextra{class in flarestack.core.injector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.injector.}}\sphinxbfcode{\sphinxupquote{MCInjector}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Core Injector Class, returns a dataset on which calculations can be
performed. This base class is tailored for injection of MC into mock
background. This can be either MC background, or scrambled real data.
\index{\_\_init\_\_() (flarestack.core.injector.MCInjector method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.injector.MCInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{calculate\_fluence() (flarestack.core.injector.MCInjector method)@\spxentry{calculate\_fluence()}\spxextra{flarestack.core.injector.MCInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.calculate_fluence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_fluence}}}{\emph{source}, \emph{scale}, \emph{source\_mc}, \emph{band\_mask}, \emph{omega}}{}
Function to calculate the fluence for a given source, and multiply
the oneweights by this. After this step, the oneweight sum is equal
to the expected neutrino number.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be calculated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} Flux scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source\_mc}} \textendash{} MC that is close to source

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{band\_mask}} \textendash{} Closeness mask for MC

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omega}} \textendash{} Solid angle covered by MC mask

\end{itemize}

\item[{Returns}] \leavevmode
Modified source MC

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_n\_exp\_single() (flarestack.core.injector.MCInjector method)@\spxentry{calculate\_n\_exp\_single()}\spxextra{flarestack.core.injector.MCInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.calculate_n_exp_single}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_n\_exp\_single}}}{\emph{source}}{}
\end{fulllineitems}

\index{calculate\_single\_source() (flarestack.core.injector.MCInjector method)@\spxentry{calculate\_single\_source()}\spxextra{flarestack.core.injector.MCInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.calculate_single_source}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_single\_source}}}{\emph{source}, \emph{scale}}{}
Calculate the weighted MC for a single source, given a flux scale
and a distance scale.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_band\_mask() (flarestack.core.injector.MCInjector method)@\spxentry{get\_band\_mask()}\spxextra{flarestack.core.injector.MCInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.get_band_mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_band\_mask}}}{\emph{source}, \emph{min\_dec}, \emph{max\_dec}}{}
\end{fulllineitems}

\index{inject\_signal() (flarestack.core.injector.MCInjector method)@\spxentry{inject\_signal()}\spxextra{flarestack.core.injector.MCInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.inject_signal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inject\_signal}}}{\emph{scale}}{}
Randomly select simulated events from the Monte Carlo dataset to
simulate a signal for each source. The source flux can be scaled by
the scale parameter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} Ratio of Injected Flux to source flux.

\item[{Returns}] \leavevmode
Set of signal events for the given IC Season.

\end{description}\end{quote}

\end{fulllineitems}

\index{select\_mc\_band() (flarestack.core.injector.MCInjector method)@\spxentry{select\_mc\_band()}\spxextra{flarestack.core.injector.MCInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.select_mc_band}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select\_mc\_band}}}{\emph{source}}{}
For a given source, selects MC events within a declination band of
width +/- 5 degrees that contains the source. Then returns the MC data
subset containing only those MC events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be simulated

\item[{Returns}] \leavevmode
mc (cut): Simulated events which lie within the band

\item[{Returns}] \leavevmode
omega: Solid Angle of the chosen band

\item[{Returns}] \leavevmode
band\_mask: The mask which removes events outside band

\end{description}\end{quote}

\end{fulllineitems}

\index{subclasses (flarestack.core.injector.MCInjector attribute)@\spxentry{subclasses}\spxextra{flarestack.core.injector.MCInjector attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MCInjector.subclasses}}\pysigline{\sphinxbfcode{\sphinxupquote{subclasses}}\sphinxbfcode{\sphinxupquote{ = \{'low\_memory\_injector': \textless{}class 'flarestack.core.injector.LowMemoryInjector'\textgreater{}\}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MockUnblindedInjector (class in flarestack.core.injector)@\spxentry{MockUnblindedInjector}\spxextra{class in flarestack.core.injector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MockUnblindedInjector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.injector.}}\sphinxbfcode{\sphinxupquote{MockUnblindedInjector}}}{\emph{season}, \emph{sources=nan}, \emph{**kwargs}}{}
If the data is not really to be unblinded, then MockUnblindedInjector
should be called. In this case, the create\_dataset function simply returns
one background scramble.
\index{\_\_init\_\_() (flarestack.core.injector.MockUnblindedInjector method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.injector.MockUnblindedInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MockUnblindedInjector.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources=nan}, \emph{**kwargs}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{create\_dataset() (flarestack.core.injector.MockUnblindedInjector method)@\spxentry{create\_dataset()}\spxextra{flarestack.core.injector.MockUnblindedInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.MockUnblindedInjector.create_dataset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_dataset}}}{\emph{scale}, \emph{pull\_corrector}}{}
Returns a background scramble
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Scrambled data

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TrueUnblindedInjector (class in flarestack.core.injector)@\spxentry{TrueUnblindedInjector}\spxextra{class in flarestack.core.injector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.TrueUnblindedInjector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.injector.}}\sphinxbfcode{\sphinxupquote{TrueUnblindedInjector}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
If the data is unblinded, then UnblindedInjector should be called. In
this case, the create\_dataset function simply returns the unblinded dataset.
\index{\_\_init\_\_() (flarestack.core.injector.TrueUnblindedInjector method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.injector.TrueUnblindedInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.TrueUnblindedInjector.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{**kwargs}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{create\_dataset() (flarestack.core.injector.TrueUnblindedInjector method)@\spxentry{create\_dataset()}\spxextra{flarestack.core.injector.TrueUnblindedInjector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.TrueUnblindedInjector.create_dataset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_dataset}}}{\emph{scale}, \emph{pull\_corrector}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{read\_injector\_dict() (in module flarestack.core.injector)@\spxentry{read\_injector\_dict()}\spxextra{in module flarestack.core.injector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.injector.read_injector_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.core.injector.}}\sphinxbfcode{\sphinxupquote{read\_injector\_dict}}}{\emph{inj\_dict}}{}
Ensures that injection dictionaries remain backwards-compatible
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{inj\_dict}} \textendash{} Injection Dictionary

\item[{Returns}] \leavevmode
Injection Dictionary compatible with new format

\end{description}\end{quote}

\end{fulllineitems}



\section{Log Likelihood}
\label{\detokenize{index:module-flarestack.core.llh}}\label{\detokenize{index:log-likelihood}}\index{flarestack.core.llh (module)@\spxentry{flarestack.core.llh}\spxextra{module}}\index{FixedEnergyLLH (class in flarestack.core.llh)@\spxentry{FixedEnergyLLH}\spxextra{class in flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{FixedEnergyLLH}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}~\index{\_\_init\_\_() (flarestack.core.llh.FixedEnergyLLH method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.llh.FixedEnergyLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{calculate\_test\_statistic() (flarestack.core.llh.FixedEnergyLLH method)@\spxentry{calculate\_test\_statistic()}\spxextra{flarestack.core.llh.FixedEnergyLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH.calculate_test_statistic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_test\_statistic}}}{\emph{params}, \emph{weights}, \emph{**kwargs}}{}
Calculates the test statistic, given the parameters. Uses numexpr
for faster calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} \textendash{} Parameters from Minimisation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} Normalised fraction of n\_s allocated to each source

\end{itemize}

\item[{Returns}] \leavevmode
2 * llh value (Equal to Test Statistic)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_acceptance\_function() (flarestack.core.llh.FixedEnergyLLH method)@\spxentry{create\_acceptance\_function()}\spxextra{flarestack.core.llh.FixedEnergyLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH.create_acceptance_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_acceptance\_function}}}{\emph{acc\_path}}{}
\end{fulllineitems}

\index{create\_energy\_functions() (flarestack.core.llh.FixedEnergyLLH method)@\spxentry{create\_energy\_functions()}\spxextra{flarestack.core.llh.FixedEnergyLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH.create_energy_functions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_energy\_functions}}}{}{}
Creates the acceptance function, which parameterises signal
acceptance as a function of declination, and the energy weighting
function, which gives the energy signal-over-background ratio
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Acceptance function, energy\_weighting\_function

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_energy\_weighting\_function() (flarestack.core.llh.FixedEnergyLLH method)@\spxentry{create\_energy\_weighting\_function()}\spxextra{flarestack.core.llh.FixedEnergyLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH.create_energy_weighting_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_energy\_weighting\_function}}}{\emph{SoB\_path}}{}
\end{fulllineitems}

\index{create\_kwargs() (flarestack.core.llh.FixedEnergyLLH method)@\spxentry{create\_kwargs()}\spxextra{flarestack.core.llh.FixedEnergyLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH.create_kwargs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_kwargs}}}{\emph{data}, \emph{pull\_corrector}, \emph{weight\_f=None}}{}
Creates a likelihood function to minimise, based on the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Dataset

\item[{Returns}] \leavevmode
LLH function that can be minimised

\end{description}\end{quote}

\end{fulllineitems}

\index{fit\_energy (flarestack.core.llh.FixedEnergyLLH attribute)@\spxentry{fit\_energy}\spxextra{flarestack.core.llh.FixedEnergyLLH attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.FixedEnergyLLH.fit_energy}}\pysigline{\sphinxbfcode{\sphinxupquote{fit\_energy}}\sphinxbfcode{\sphinxupquote{ = False}}}
\end{fulllineitems}


\end{fulllineitems}

\index{LLH (class in flarestack.core.llh)@\spxentry{LLH}\spxextra{class in flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{LLH}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
Base class LLH.
\index{\_\_init\_\_() (flarestack.core.llh.LLH method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{assume\_background() (flarestack.core.llh.LLH static method)@\spxentry{assume\_background()}\spxextra{flarestack.core.llh.LLH static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.assume_background}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{assume\_background}}}{\emph{n\_s}, \emph{n\_coincident}, \emph{n\_all}}{}
To save time with likelihood calculation, it can be assumed that
all events defined as “non-coincident”, because of distance in space
and time to the source, are in fact background events. This is
equivalent to setting S=0 for all non-coincident events. IN this
case, the likelihood can be calculated as the product of the number
of non-coincident events, and the likelihood of an event which has S=0.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_s}} \textendash{} Array of expected number of events

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_coincident}} \textendash{} Number of events that were not assumed to have S=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_all}} \textendash{} The total number of events

\end{itemize}

\item[{Returns}] \leavevmode
Log Likelihood value for the given

\end{description}\end{quote}

\end{fulllineitems}

\index{background\_pdf() (flarestack.core.llh.LLH method)@\spxentry{background\_pdf()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.background_pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{background\_pdf}}}{\emph{source}, \emph{cut\_data}}{}
Calculates the value of the background spatial PDF for a given
source for each event in the coincident data subsample. Thus is done
by calling the self.bkg\_spline spline function, which was fitted to
the Sin(Declination) distribution of the data.

If there is a signal Time PDF given, then the background time PDF
is also calculated for each event. This is assumed to be a normalised
uniform distribution for the season.

Returns either the background spatial PDF values, or the product of the
background spatial and time PDFs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cut\_data}} \textendash{} Subset of Dataset with coincident events

\end{itemize}

\item[{Returns}] \leavevmode
Array of Background Spacetime PDF values

\end{description}\end{quote}

\end{fulllineitems}

\index{background\_spatial() (flarestack.core.llh.LLH method)@\spxentry{background\_spatial()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.background_spatial}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{background\_spatial}}}{\emph{cut\_data}}{}
\end{fulllineitems}

\index{calculate\_test\_statistic() (flarestack.core.llh.LLH method)@\spxentry{calculate\_test\_statistic()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.calculate_test_statistic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_test\_statistic}}}{\emph{params}, \emph{weights}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{create() (flarestack.core.llh.LLH class method)@\spxentry{create()}\spxextra{flarestack.core.llh.LLH class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
\end{fulllineitems}

\index{create\_background\_function() (flarestack.core.llh.LLH method)@\spxentry{create\_background\_function()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.create_background_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_background\_function}}}{}{}
\end{fulllineitems}

\index{create\_energy\_functions() (flarestack.core.llh.LLH method)@\spxentry{create\_energy\_functions()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.create_energy_functions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_energy\_functions}}}{}{}
Creates the acceptance function, which parameterises signal
acceptance as a function of declination, and the energy weighting
function, which gives the energy signal-over-background ratio
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Acceptance function, energy\_weighting\_function

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_kwargs() (flarestack.core.llh.LLH method)@\spxentry{create\_kwargs()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.create_kwargs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_kwargs}}}{\emph{data}, \emph{pull\_corrector}, \emph{weight\_f=None}}{}
\end{fulllineitems}

\index{create\_llh\_function() (flarestack.core.llh.LLH method)@\spxentry{create\_llh\_function()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.create_llh_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_llh\_function}}}{\emph{data}, \emph{pull\_corrector}, \emph{weight\_f=None}}{}
Creates a likelihood function to minimise, based on the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Dataset

\item[{Returns}] \leavevmode
LLH function that can be minimised

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_injected\_parameters() (flarestack.core.llh.LLH class method)@\spxentry{get\_injected\_parameters()}\spxextra{flarestack.core.llh.LLH class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.get_injected_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{get\_injected\_parameters}}}{\emph{mh\_dict}}{}
\end{fulllineitems}

\index{get\_parameters() (flarestack.core.llh.LLH class method)@\spxentry{get\_parameters()}\spxextra{flarestack.core.llh.LLH class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.get_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{get\_parameters}}}{\emph{llh\_dict}}{}
\end{fulllineitems}

\index{register\_subclass() (flarestack.core.llh.LLH class method)@\spxentry{register\_subclass()}\spxextra{flarestack.core.llh.LLH class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.register_subclass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{register\_subclass}}}{\emph{llh\_name}}{}
Adds a new subclass of EnergyPDF, with class name equal to
“energy\_pdf\_name”.

\end{fulllineitems}

\index{return\_injected\_parameters() (flarestack.core.llh.LLH static method)@\spxentry{return\_injected\_parameters()}\spxextra{flarestack.core.llh.LLH static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.return_injected_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{return\_injected\_parameters}}}{\emph{mh\_dict}}{}
\end{fulllineitems}

\index{return\_llh\_parameters() (flarestack.core.llh.LLH static method)@\spxentry{return\_llh\_parameters()}\spxextra{flarestack.core.llh.LLH static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.return_llh_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{return\_llh\_parameters}}}{\emph{llh\_dict}}{}
\end{fulllineitems}

\index{select\_spatially\_coincident\_data() (flarestack.core.llh.LLH method)@\spxentry{select\_spatially\_coincident\_data()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.select_spatially_coincident_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select\_spatially\_coincident\_data}}}{\emph{data}, \emph{sources}}{}
Checks each source, and only identifies events in data which are
both spatially and time-coincident with the source. Spatial
coincidence is defined as a +/- 5 degree box centered on the  given
source. Time coincidence is determined by the parameters of the LLH
Time PDF. Produces a mask for the dataset, which removes all events
which are not coincident with at least one source.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Dataset to be tested

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sources}} \textendash{} Sources to be tested

\end{itemize}

\item[{Returns}] \leavevmode
Mask to remove

\end{description}\end{quote}

\end{fulllineitems}

\index{signal\_pdf() (flarestack.core.llh.LLH method)@\spxentry{signal\_pdf()}\spxextra{flarestack.core.llh.LLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.signal_pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{signal\_pdf}}}{\emph{source}, \emph{cut\_data}}{}
Calculates the value of the signal spatial PDF for a given source
for each event in the coincident data subsample. If there is a Time PDF
given, also calculates the value of the signal Time PDF for each event.
Returns either the signal spatial PDF values, or the product of the
signal spatial and time PDFs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cut\_data}} \textendash{} Subset of Dataset with coincident events

\end{itemize}

\item[{Returns}] \leavevmode
Array of Signal Spacetime PDF values

\end{description}\end{quote}

\end{fulllineitems}

\index{subclasses (flarestack.core.llh.LLH attribute)@\spxentry{subclasses}\spxextra{flarestack.core.llh.LLH attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.LLH.subclasses}}\pysigline{\sphinxbfcode{\sphinxupquote{subclasses}}\sphinxbfcode{\sphinxupquote{ = \{'fixed\_energy': \textless{}class 'flarestack.core.llh.FixedEnergyLLH'\textgreater{}, 'spatial': \textless{}class 'flarestack.core.llh.SpatialLLH'\textgreater{}, 'standard': \textless{}class 'flarestack.core.llh.StandardLLH'\textgreater{}, 'standard\_matrix': \textless{}class 'flarestack.core.llh.StandardMatrixLLH'\textgreater{}, 'standard\_overlapping': \textless{}class 'flarestack.core.llh.StandardOverlappingLLH'\textgreater{}\}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{SpatialLLH (class in flarestack.core.llh)@\spxentry{SpatialLLH}\spxextra{class in flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.SpatialLLH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{SpatialLLH}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
Most basic LLH, in which only spatial, and optionally also temporal,
information is included. No Energy PDF is used, and no energy weighting
is applied.
\index{\_\_init\_\_() (flarestack.core.llh.SpatialLLH method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.llh.SpatialLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.SpatialLLH.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{calculate\_test\_statistic() (flarestack.core.llh.SpatialLLH method)@\spxentry{calculate\_test\_statistic()}\spxextra{flarestack.core.llh.SpatialLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.SpatialLLH.calculate_test_statistic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_test\_statistic}}}{\emph{params}, \emph{weights}, \emph{**kwargs}}{}
Calculates the test statistic, given the parameters. Uses numexpr
for faster calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} \textendash{} Parameters from Minimisation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} Normalised fraction of n\_s allocated to each source

\end{itemize}

\item[{Returns}] \leavevmode
2 * llh value (Equal to Test Statistic)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_energy\_function() (flarestack.core.llh.SpatialLLH method)@\spxentry{create\_energy\_function()}\spxextra{flarestack.core.llh.SpatialLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.SpatialLLH.create_energy_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_energy\_function}}}{}{}
In the most simple case of spatial-only weighting, you would
neglect the energy weighting of events. Then, you can simply assume
that the detector acceptance is roughly proportional to the data rate,
i.e assuming that the incident background atmospheric neutrino flux
is uniform. Thus the acceptance of the detector is simply the
background spatial PDF (which is a spline fitted to data as a
function of declination). This method does, admittedly neglect the
fact that background in the southern hemisphere is mainly composed of
muon bundles, rather than atmospheric neutrinos. Still, it’s slighty
better than assuming a uniform detector acceptance
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
1D linear interpolation

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_llh\_function() (flarestack.core.llh.SpatialLLH method)@\spxentry{create\_llh\_function()}\spxextra{flarestack.core.llh.SpatialLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.SpatialLLH.create_llh_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_llh\_function}}}{\emph{data}, \emph{pull\_corrector}, \emph{weight\_f=None}}{}
Creates a likelihood function to minimise, based on the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Dataset

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pull\_corrector}} \textendash{} pull\_corrector

\end{itemize}

\item[{Returns}] \leavevmode
LLH function that can be minimised

\end{description}\end{quote}

\end{fulllineitems}

\index{fit\_energy (flarestack.core.llh.SpatialLLH attribute)@\spxentry{fit\_energy}\spxextra{flarestack.core.llh.SpatialLLH attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.SpatialLLH.fit_energy}}\pysigline{\sphinxbfcode{\sphinxupquote{fit\_energy}}\sphinxbfcode{\sphinxupquote{ = False}}}
\end{fulllineitems}


\end{fulllineitems}

\index{StandardLLH (class in flarestack.core.llh)@\spxentry{StandardLLH}\spxextra{class in flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{StandardLLH}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}~\index{\_\_init\_\_() (flarestack.core.llh.StandardLLH method)@\spxentry{\_\_init\_\_()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{calculate\_test\_statistic() (flarestack.core.llh.StandardLLH method)@\spxentry{calculate\_test\_statistic()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.calculate_test_statistic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_test\_statistic}}}{\emph{params}, \emph{weights}, \emph{**kwargs}}{}
Calculates the test statistic, given the parameters. Uses numexpr
for faster calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} \textendash{} Parameters from Minimisation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} Normalised fraction of n\_s allocated to each source

\end{itemize}

\item[{Returns}] \leavevmode
2 * llh value (Equal to Test Statistic)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_SoB\_energy\_cache() (flarestack.core.llh.StandardLLH method)@\spxentry{create\_SoB\_energy\_cache()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.create_SoB_energy_cache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_SoB\_energy\_cache}}}{\emph{cut\_data}}{}
Evaluates the Log(Signal/Background) values for all coincident
data. For each value of gamma in self.gamma\_support\_points, calculates
the Log(Signal/Background) values for the coincident data. Then saves
each weight array to a dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{cut\_data}} \textendash{} Subset of the data containing only coincident events

\item[{Returns}] \leavevmode
Dictionary containing SoB values for each event for each

\end{description}\end{quote}

gamma value.

\end{fulllineitems}

\index{create\_acceptance\_function() (flarestack.core.llh.StandardLLH method)@\spxentry{create\_acceptance\_function()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.create_acceptance_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_acceptance\_function}}}{}{}
Creates a 2D linear interpolation of the acceptance of the detector
for the given season, as a function of declination and gamma. Returns
this interpolation function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
2D linear interpolation

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_energy\_functions() (flarestack.core.llh.StandardLLH method)@\spxentry{create\_energy\_functions()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.create_energy_functions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_energy\_functions}}}{}{}
Creates the acceptance function, which parameterises signal
acceptance as a function of declination, and the energy weighting
function, which gives the energy signal-over-background ratio
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Acceptance function, energy\_weighting\_function

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_kwargs() (flarestack.core.llh.StandardLLH method)@\spxentry{create\_kwargs()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.create_kwargs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_kwargs}}}{\emph{data}, \emph{pull\_corrector}, \emph{weight\_f=None}}{}
Creates a likelihood function to minimise, based on the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Dataset

\item[{Returns}] \leavevmode
LLH function that can be minimised

\end{description}\end{quote}

\end{fulllineitems}

\index{estimate\_energy\_weights() (flarestack.core.llh.StandardLLH method)@\spxentry{estimate\_energy\_weights()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.estimate_energy_weights}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{estimate\_energy\_weights}}}{\emph{gamma}, \emph{energy\_SoB\_cache}}{}
Quickly estimates the value of Signal/Background for Gamma.
Uses pre-calculated values for first and second derivatives.
Uses a Taylor series to estimate S(gamma), unless SoB has already
been calculated for a given gamma.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} Spectral Index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{energy\_SoB\_cache}} \textendash{} Weight cache

\end{itemize}

\item[{Returns}] \leavevmode
Estimated value for S(gamma)

\end{description}\end{quote}

\end{fulllineitems}

\index{fit\_energy (flarestack.core.llh.StandardLLH attribute)@\spxentry{fit\_energy}\spxextra{flarestack.core.llh.StandardLLH attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.fit_energy}}\pysigline{\sphinxbfcode{\sphinxupquote{fit\_energy}}\sphinxbfcode{\sphinxupquote{ = True}}}
\end{fulllineitems}

\index{new\_acceptance() (flarestack.core.llh.StandardLLH method)@\spxentry{new\_acceptance()}\spxextra{flarestack.core.llh.StandardLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.new_acceptance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{new\_acceptance}}}{\emph{source}, \emph{params=None}}{}
Calculates the detector acceptance for a given source, using the
2D interpolation of the acceptance as a function of declination and
gamma. If gamma IS NOT being fit, uses the default value of gamma for
weighting (determined in \_\_init\_\_). If gamma IS being fit, it will be
the last entry in the parameter array, and is the acceptance uses
this value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} \textendash{} Source to be considered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} \textendash{} Parameter array

\end{itemize}

\item[{Returns}] \leavevmode
Value for the acceptance of the detector, in the given

\end{description}\end{quote}

season, for the source

\end{fulllineitems}

\index{return\_injected\_parameters() (flarestack.core.llh.StandardLLH static method)@\spxentry{return\_injected\_parameters()}\spxextra{flarestack.core.llh.StandardLLH static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.return_injected_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{return\_injected\_parameters}}}{\emph{mh\_dict}}{}
\end{fulllineitems}

\index{return\_llh\_parameters() (flarestack.core.llh.StandardLLH static method)@\spxentry{return\_llh\_parameters()}\spxextra{flarestack.core.llh.StandardLLH static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardLLH.return_llh_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{return\_llh\_parameters}}}{\emph{llh\_dict}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{StandardMatrixLLH (class in flarestack.core.llh)@\spxentry{StandardMatrixLLH}\spxextra{class in flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardMatrixLLH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{StandardMatrixLLH}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}~\index{create\_kwargs() (flarestack.core.llh.StandardMatrixLLH method)@\spxentry{create\_kwargs()}\spxextra{flarestack.core.llh.StandardMatrixLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardMatrixLLH.create_kwargs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_kwargs}}}{\emph{data}, \emph{pull\_corrector}, \emph{weight\_f=None}}{}
Creates a likelihood function to minimise, based on the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Dataset

\item[{Returns}] \leavevmode
LLH function that can be minimised

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StandardOverlappingLLH (class in flarestack.core.llh)@\spxentry{StandardOverlappingLLH}\spxextra{class in flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardOverlappingLLH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{StandardOverlappingLLH}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}~\index{calculate\_test\_statistic() (flarestack.core.llh.StandardOverlappingLLH method)@\spxentry{calculate\_test\_statistic()}\spxextra{flarestack.core.llh.StandardOverlappingLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardOverlappingLLH.calculate_test_statistic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_test\_statistic}}}{\emph{params}, \emph{weights}, \emph{**kwargs}}{}
Calculates the test statistic, given the parameters. Uses numexpr
for faster calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} \textendash{} Parameters from Minimisation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} Normalised fraction of n\_s allocated to each source

\end{itemize}

\item[{Returns}] \leavevmode
2 * llh value (Equal to Test Statistic)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_kwargs() (flarestack.core.llh.StandardOverlappingLLH method)@\spxentry{create\_kwargs()}\spxextra{flarestack.core.llh.StandardOverlappingLLH method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.StandardOverlappingLLH.create_kwargs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_kwargs}}}{\emph{data}, \emph{pull\_corrector}, \emph{weight\_f=None}}{}
Creates a likelihood function to minimise, based on the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Dataset

\item[{Returns}] \leavevmode
LLH function that can be minimised

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{generate\_dynamic\_flare\_class() (in module flarestack.core.llh)@\spxentry{generate\_dynamic\_flare\_class()}\spxextra{in module flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.generate_dynamic_flare_class}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{generate\_dynamic\_flare\_class}}}{\emph{season}, \emph{sources}, \emph{llh\_dict}}{}
\end{fulllineitems}

\index{read\_llh\_dict() (in module flarestack.core.llh)@\spxentry{read\_llh\_dict()}\spxextra{in module flarestack.core.llh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.core.llh.read_llh_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.core.llh.}}\sphinxbfcode{\sphinxupquote{read\_llh\_dict}}}{\emph{llh\_dict}}{}
Ensures that llh dictionaries remain backwards-compatible
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{llh\_dict}} \textendash{} LLH Dictionary

\item[{Returns}] \leavevmode
LLH Dictionary compatible with new format

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Utils}
\label{\detokenize{index:utils}}

\section{IceCube Utils}
\label{\detokenize{index:module-flarestack.icecube_utils.dataset_loader}}\label{\detokenize{index:icecube-utils}}\index{flarestack.icecube\_utils.dataset\_loader (module)@\spxentry{flarestack.icecube\_utils.dataset\_loader}\spxextra{module}}\index{convert\_grl() (in module flarestack.icecube\_utils.dataset\_loader)@\spxentry{convert\_grl()}\spxextra{in module flarestack.icecube\_utils.dataset\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.icecube_utils.dataset_loader.convert_grl}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.icecube\_utils.dataset\_loader.}}\sphinxbfcode{\sphinxupquote{convert\_grl}}}{\emph{season}}{}
\end{fulllineitems}

\index{data\_loader() (in module flarestack.icecube\_utils.dataset\_loader)@\spxentry{data\_loader()}\spxextra{in module flarestack.icecube\_utils.dataset\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.icecube_utils.dataset_loader.data_loader}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.icecube\_utils.dataset\_loader.}}\sphinxbfcode{\sphinxupquote{data\_loader}}}{\emph{data\_path}, \emph{floor=True}, \emph{cut\_fields=True}}{}
Helper function to load data for a given season/set of season.
Adds sinDec field if this is not available, and combines multiple years
of data is appropriate (different sets of data from the same icecube
configuration should be given as a list)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_path}} \textendash{} Path to data or list of paths to data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cut\_fields}} \textendash{} Boolean to remove unused fields from datasets on loading

\end{itemize}

\item[{Returns}] \leavevmode
Loaded Dataset (experimental or MC)

\end{description}\end{quote}

\end{fulllineitems}

\index{grl\_loader() (in module flarestack.icecube\_utils.dataset\_loader)@\spxentry{grl\_loader()}\spxextra{in module flarestack.icecube\_utils.dataset\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.icecube_utils.dataset_loader.grl_loader}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.icecube\_utils.dataset\_loader.}}\sphinxbfcode{\sphinxupquote{grl\_loader}}}{\emph{season}}{}
\end{fulllineitems}

\index{verify\_grl\_with\_data() (in module flarestack.icecube\_utils.dataset\_loader)@\spxentry{verify\_grl\_with\_data()}\spxextra{in module flarestack.icecube\_utils.dataset\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:flarestack.icecube_utils.dataset_loader.verify_grl_with_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flarestack.icecube\_utils.dataset\_loader.}}\sphinxbfcode{\sphinxupquote{verify\_grl\_with\_data}}}{\emph{seasons}}{}
\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-flarestack.utils}}\index{flarestack.utils (module)@\spxentry{flarestack.utils}\spxextra{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{f}
\item\relax\sphinxstyleindexentry{flarestack.core.energy\_pdf}\sphinxstyleindexpageref{index:\detokenize{module-flarestack.core.energy_pdf}}
\item\relax\sphinxstyleindexentry{flarestack.core.injector}\sphinxstyleindexpageref{index:\detokenize{module-flarestack.core.injector}}
\item\relax\sphinxstyleindexentry{flarestack.core.llh}\sphinxstyleindexpageref{index:\detokenize{module-flarestack.core.llh}}
\item\relax\sphinxstyleindexentry{flarestack.core.time\_pdf}\sphinxstyleindexpageref{index:\detokenize{module-flarestack.core.time_pdf}}
\item\relax\sphinxstyleindexentry{flarestack.icecube\_utils.dataset\_loader}\sphinxstyleindexpageref{index:\detokenize{module-flarestack.icecube_utils.dataset_loader}}
\item\relax\sphinxstyleindexentry{flarestack.utils}\sphinxstyleindexpageref{index:\detokenize{module-flarestack.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}